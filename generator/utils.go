package generator

import (
	"fmt"
	"io"
	"path/filepath"
	"strings"
)

func writeStartFile(w io.Writer, pkg, info string, defaultImports ...string) {
	fmt.Fprint(w, "// Code generated by https://github.com/defany/govk. DO NOT EDIT.\n")

	if info != "" {
		fmt.Fprint(w, info+"\n")
	}

	fmt.Fprint(w, "\n")
	fmt.Fprint(w, "package "+pkg+"\n\n")

	if len(defaultImports) == 0 {
		return
	}

	fmt.Fprint(w, "import (\n")

	for _, i := range defaultImports {
		fmt.Fprint(w, fmt.Sprintf("\t%q\n", i))
	}

	fmt.Fprint(w, ")\n\n")
}

func writeStartMethodFile(w io.Writer, pkg string) {
	fmt.Fprint(w, fmt.Sprintf("type %s struct {\n\tapi *api.API\n}\n\nfunc New%[1]s(api *api.API) *%[1]s {\n\treturn &%[1]s{\n\t\tapi: api,\n\t}\n}\n\n", upFirstAny(pkg)))
}

func getFullName(name string) string {
	if isGoType(name) {
		return name
	}

	split := strings.Split(name, "_")

	if len(split) == 1 {
		return upFirstAny(name)
	}

	for i := 0; i < len(split); i++ {
		split[i] = upFirstAny(split[i])
	}

	return strings.Join(split, "")
}

func getObjectName(name string) string {
	if isGoType(name) {
		return name
	}

	if strings.HasPrefix(name, "map[string]") {
		mapType := strings.TrimPrefix(name, "map[string]")
		return "map[string]" + getObjectName(mapType)
	}

	split := strings.Split(name, "_")

	if len(split) == 1 {
		return name
	}

	for i := 0; i < len(split); i++ {
		split[i] = split[i]
	}

	return strings.ToLower(split[0])
}

func getFullObjectName(name string) string {
	if isGoType(name) {
		return name
	}

	if strings.HasPrefix(name, "map[string]") {
		mapType := strings.TrimPrefix(name, "map[string]")
		return "map[string]" + getFullObjectName(mapType)
	}

	split := strings.Split(name, "_")

	if len(split) == 1 {
		return upFirstAny(name)
	}

	for i := 0; i < len(split); i++ {
		split[i] = upFirstAny(split[i])
	}

	if strings.HasSuffix(name, "_response") {
		return split[0] + strings.Join(split[1:len(split)-1], "") + split[len(split)-1]
	}

	return split[0] + strings.Join(split[1:], "")
}

func getSimpleType(t string) string {
	switch t {
	case "string":
		return "string"
	case "integer":
		return "int"
	case "number":
		return "float64"
	case "boolean":
		return "bool"
	}

	panic("unknown Field type: " + t)
}

func getRefName(refRaw string) string {
	return filepath.Base(refRaw)
}

func editEnumSpace(s string) string {
	s = strings.ReplaceAll(s, " ", "_")
	s = strings.ReplaceAll(s, ",", "_")
	s = strings.ReplaceAll(s, "-", "")
	s = strings.ReplaceAll(s, "&", "And")

	return s
}

func getTabs(nestingLvl int) (t string) {
	for i := 0; i < nestingLvl; i++ {
		t += "\t"
	}
	return
}

func isGoType(s string) bool {
	switch s {
	case "string", "int", "bool", "float64", "interface{}":
		return true
	default:
		return false
	}
}

func upFirstAny(s string) string {
	return strings.Title(s)
}

func removeDuplicateStr(strSlice []string) []string {
	allKeys := make(map[string]bool)
	var list []string
	for _, item := range strSlice {
		if _, value := allKeys[item]; !value {
			allKeys[item] = true
			list = append(list, item)
		}
	}
	return list
}

func getArrayBrackets(arrayNestingLvl int) (s string) {
	for i := 0; i < arrayNestingLvl; i++ {
		s += "[]"
	}
	return
}

func getFullMethodName(name string) string {
	split := strings.Split(name, ".")

	if len(split) != 2 {
		panic(name)
	}

	split[0] = upFirstAny(split[0])
	split[1] = upFirstAny(split[1])

	return strings.Join(split, "")
}

func getMethodName(name string) string {
	if isGoType(name) {
		return name
	}

	if strings.HasPrefix(name, "map[string]") {
		mapType := strings.TrimPrefix(name, "map[string]")
		return "map[string]" + getObjectName(mapType)
	}

	split := strings.Split(name, ".")

	if len(split) == 1 {
		return name
	}

	for i := 0; i < len(split); i++ {
		split[i] = split[i]
	}

	return strings.ToLower(split[0])
}

func buildPossibleErrors(errNames []string) string {
	errs := make([]string, len(errNames))
	copy(errs, errNames)

	for i, e := range errs {
		errs[i] = getErrorName(e)
	}

	return strings.Join(errs, ", ")
}

func getSubcodeName(name string) string {
	split := strings.Split(name, "_")

	for i := 0; i < len(split); i++ {
		split[i] = upFirstAny(split[i])
	}

	return strings.Join(split, "")
}

func getErrorName(name string) string {
	split := strings.Split(name, "_")

	for i := 1; i < len(split); i++ {
		split[i] = upFirstAny(split[i])
	}

	return split[1] + "_" + strings.Join(split[2:], "")
}
