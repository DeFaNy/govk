package generator

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

func writeStartFile(w io.Writer, pkg, info string, imports []string, defaultImports ...string) {
	fmt.Fprint(w, "// Code generated by https://github.com/elias506/vk-sdk. DO NOT EDIT.\n")

	if info != "" {
		fmt.Fprint(w, info+"\n")
	}

	fmt.Fprint(w, "\n")
	fmt.Fprint(w, "package "+pkg+"\n\n")

	if imports != nil || len(defaultImports) > 0 {
		fmt.Fprint(w, "import (\n")
	}

	if len(defaultImports) > 0 {
		for _, i := range defaultImports {
			fmt.Fprint(w, fmt.Sprintf("\t%q\n", i))
		}
	}

	if len(imports) == 0 {
		if len(defaultImports) > 0 {
			fmt.Fprint(w, ")\n\n")
			return
		}
		return
	}

	for _, i := range imports {
		n := strings.Split(i, " ")
		if pkg == n[0] {
			continue
		}
		fmt.Fprint(w, fmt.Sprintf("\t%s %q\n", n[0], n[1]))
	}
	fmt.Fprint(w, ")\n\n")
}

func writeStartMethodFile(w io.Writer, pkg string) {
	fmt.Fprint(w, fmt.Sprintf("const methodsGroup = \"%s.\"\n\n", pkg))
	fmt.Fprint(w, fmt.Sprintf("type %s struct {\n\tmethodsGroup string\n\tapi *api.API\n}\n\nfunc New%[1]s(api *api.API) *%[1]s {\n\treturn &%[1]s{\n\t\tmethodsGroup: methodsGroup,\n\t\tapi: api,\n\t}\n}\n\n", upFirstAny(pkg)))
}

func addImport(file string, imports ...string) {
	f, err := os.OpenFile(file, os.O_RDWR, 0644)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()
	scanner := bufio.NewScanner(f)

	temp := []string{}

	foundImport := false

	for scanner.Scan() {
		line := scanner.Text()

		if foundImport {
			temp = append(temp, imports...)
			foundImport = false
		}

		if strings.Contains(line, "import (") {
			foundImport = true
		}

		temp = append(temp, line+"\n")
	}

	if err := scanner.Err(); err != nil {
		fmt.Println(err)
		return
	}

	f.Seek(0, io.SeekStart)
	f.Truncate(0)

	writer := bufio.NewWriter(f)
	for _, line := range temp {
		fmt.Fprint(writer, line)
	}
	writer.Flush()
}

func getFullName(name string) string {
	if isGoType(name) {
		return name
	}

	split := strings.Split(name, "_")

	if len(split) == 1 {
		return upFirstAny(name)
	}

	for i := 0; i < len(split); i++ {
		split[i] = upFirstAny(split[i])
	}

	return strings.Join(split, "")
}

func getObjectName(name string) string {
	if isGoType(name) {
		return name
	}

	if strings.HasPrefix(name, "map[string]") {
		mapType := strings.TrimPrefix(name, "map[string]")
		return "map[string]" + getObjectName(mapType)
	}

	split := strings.Split(name, "_")

	if len(split) == 1 {
		return name
	}

	for i := 0; i < len(split); i++ {
		split[i] = split[i]
	}

	return strings.ToLower(split[0])
}

func getFullObjectName(name string) string {
	if isGoType(name) {
		return name
	}

	if strings.HasPrefix(name, "map[string]") {
		mapType := strings.TrimPrefix(name, "map[string]")
		return "map[string]" + getFullObjectName(mapType)
	}

	split := strings.Split(name, "_")

	if len(split) == 1 {
		return upFirstAny(name)
	}

	for i := 0; i < len(split); i++ {
		split[i] = upFirstAny(split[i])
	}

	if strings.HasSuffix(name, "_response") {
		return split[0] + strings.Join(split[1:len(split)-1], "") + split[len(split)-1]
	}

	return split[0] + strings.Join(split[1:], "")
}

func getSimpleType(t string) string {
	switch t {
	case "string":
		return "string"
	case "integer":
		return "int"
	case "number":
		return "float64"
	case "boolean":
		return "bool"
	}

	panic("unknown Field type: " + t)
}

func getRefName(refRaw string) string {
	return filepath.Base(refRaw)
}

func editEnumSpace(s string) string {
	s = strings.ReplaceAll(s, " ", "_")
	s = strings.ReplaceAll(s, ",", "_")
	s = strings.ReplaceAll(s, "-", "")
	s = strings.ReplaceAll(s, "&", "And")

	return s
}

func getTabs(nestingLvl int) (t string) {
	for i := 0; i < nestingLvl; i++ {
		t += "\t"
	}
	return
}

func isGoType(s string) bool {
	switch s {
	case "string", "int", "bool", "float64", "interface{}":
		return true
	default:
		return false
	}
}

func upFirstAny(s string) string {
	return strings.Title(s)
}

func removeDuplicateStr(strSlice []string) []string {
	allKeys := make(map[string]bool)
	var list []string
	for _, item := range strSlice {
		if _, value := allKeys[item]; !value {
			allKeys[item] = true
			list = append(list, item)
		}
	}
	return list
}

func getArrayBrackets(arrayNestingLvl int) (s string) {
	for i := 0; i < arrayNestingLvl; i++ {
		s += "[]"
	}
	return
}

func getFullMethodName(name string) string {
	split := strings.Split(name, ".")

	if len(split) != 2 {
		panic(name)
	}

	split[0] = upFirstAny(split[0])
	split[1] = upFirstAny(split[1])

	return strings.Join(split, "")
}

func getMethodName(name string) string {
	if isGoType(name) {
		return name
	}

	if strings.HasPrefix(name, "map[string]") {
		mapType := strings.TrimPrefix(name, "map[string]")
		return "map[string]" + getObjectName(mapType)
	}

	split := strings.Split(name, ".")

	if len(split) == 1 {
		return name
	}

	for i := 0; i < len(split); i++ {
		split[i] = split[i]
	}

	return strings.ToLower(split[0])
}

func buildPossibleErrors(errNames []string) string {
	errs := make([]string, len(errNames))
	copy(errs, errNames)

	for i, e := range errs {
		errs[i] = getErrorName(e)
	}

	return strings.Join(errs, ", ")
}

func getSubcodeName(name string) string {
	split := strings.Split(name, "_")

	for i := 0; i < len(split); i++ {
		split[i] = upFirstAny(split[i])
	}

	return strings.Join(split, "")
}

func getErrorName(name string) string {
	split := strings.Split(name, "_")

	for i := 1; i < len(split); i++ {
		split[i] = upFirstAny(split[i])
	}

	return split[1] + "_" + strings.Join(split[2:], "")
}
